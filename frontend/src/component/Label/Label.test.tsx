//Label.test.tsx
import React from "react";
import { render, screen } from "@testing-library/react";
import "@testing-library/jest-dom";
import { Label } from "./Label";

describe("Label component", () => {
  test("renders with default classes and text content", () => {
    render(<Label>Hello World</Label>);
    //Radix Label renders an HTML label by default
    const label = screen.getByText(/hello world/i);

    //Ensure the label is in the document
    expect(label).toBeInTheDocument();

    //Check if the base SCSS class (e.g. styles.labelBase) is applied.
    //The "labelBase" class is generated by cva(styles.labelBase, { ... }).
    //Verify that label has it included.
    //The actual class name depends on your SCSS module output,
    //but we can check if the final root contains the substring "labelBase" or a hashed version.
    //For a more direct check, you'd do:
    //expect(label).toHaveClass('labelBase')
    //if your bundler retains that exact class name.
    //If itâ€™s hashed or scoped, adapt accordingly.
    expect(label.className).toMatch(/labelBase/);
  });

  test("applies custom className in addition to default", () => {
    render(<Label className="custom-class">Label Text</Label>);
    const label = screen.getByText(/label text/i);

    //The merged className should include both the base label class and "custom-class".
    expect(label.className).toContain("labelBase");
    expect(label.className).toContain("custom-class");
  });

  test("passes other props such as htmlFor", () => {
    render(<Label htmlFor="test-input">Input Label</Label>);
    const label = screen.getByText(/input label/i);

    //The label should have htmlFor="test-input" attribute
    //This helps associate it with an input element
    expect(label).toHaveAttribute("for", "test-input");
  });

  test("renders children correctly", () => {
    render(<Label>This is a label</Label>);
    const label = screen.getByText(/this is a label/i);
    expect(label).toBeInTheDocument();
  });
});
